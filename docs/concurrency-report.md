## 동시성 이슈란?
여러 프로세스나 쓰레드가 동시에 동일한 리소스에 접근할 때 발생하는 문제로,<br>
동시성 이슈는 주로 [`프로세스 간 경합`](#프로세스-간-경합), [`리소스 공유`](#리소스-공유) 그리고 [`비동기 실행 환경`](#비동기-실행-환경)에서 발생합니다.<br><br>
### 프로세스 간 경합
여러 프로세스가 동일한 자원을 사용하려고 할 때 발생하는 경합은, 자원의 불규칙적인 사용을 초래하여 데이터 일관성 문제를 발생시킵니다.<br>
예를 들어, 두 개의 트랜잭션이 동일한 데이터 항목에 대해 동시에 업데이트를 시도할 경우 `경쟁조건`(Race Condition)이 발생할 수 있습니다.<br><br>

### 리소스 공유
공통의 리소스를 여러 쓰레드가 동시에 접근할 때, 적절한 동기화가 이루어지지 않으면 데이터 손상 및 불일치가 발생힐 수 있습니다.<br>
이로 인해 중요한 데이터가 손실되거나 변형될 위험이 있습니다.<br><br>

### 비동기 실행 환경
비동기로 실행되는 여러 작업들은 예측되지 않는 순서로 처리될 수 있으며,<br>
이로 인해 작업 간의 데이터 의존성이 손상될 수 있습니다. 이는 결과적으로 일관되지 않은 상태를 초래할 수 있습니다.<br><br>

## 동시성 이슈의 해결책
동시성 이슈를 제어하기 위해서는 동시성 제어 메커니즘을 선택하는 것은 필수적입니다.<br>
이 보고서는 다양한 동시성 제어 기법 중 [`데이터 잠금`](#데이터-잠금)을 통한 해결책을 중심으로 설명합니다.<br>
> 💡 `Mysql`의 `InnoDB`스토리지 엔진, `kotlin`, `spring`기반의 애플리케이션을 중심으로 설명합니다.
> `MySQL`의 `InnoDB`스토리지 엔진은 `mvcc`(Multi-Version Concurrency Control)를 통해 동시성을 관리하며, 이는 읽기 작업을 잠금 없이 수행할 수 있게 합니다.<br>
> 그러나 수정 작업에서는 여전히 잠금 기반의 접근이 필요합니다.

<br>

### 데이터 잠금
- `S락`(Shared Lock)<br>
    데이터에 대한 읽기 작업을 여러 트랜잭션이 동시에 수행할 수 있도록 허용하지만, 데이터의 수정은 차단합니다.<br>
    이는 `FOR SHARE`구문을 통해 구현할 수 있습니다.<br>
    ```SQL
    SELECT * FROM Table WHERE id = ? FOR SHARE;
    ```
    > 💡 `InnoDB`는 실제로 읽기 작업 중 공유 잠금이 필요하지 않도록 설계되어 있습니다.<br>
    > 그러나 특정 시점의 데이터 일관성을 보장하기 위해 `mvcc`의 스냅샷을 활용해 데이터 읽기의 효율성을 높입니다.
    
- `X락`(Exclusive Lock)<br>
    특정 트랜잭션이 데이터 수정 시 다른 모든 접근을 차단합니다. 이는 데이터 수정의 일관성을 보장합니다.<br>
    이는 `FOR UPDATE`구문을 통해 구현할 수 있습니다.<br>
    ```SQL
    SELECT * FROM Table WHERE id = ? FOR UPDATE;
    ```
    > 💡 `InnoDB`가 데이터를 읽을 때 잠금을 피하도록 하는 반면, 데이터를 수정할 때는 여전히 배타 잠금을 사용하여 무결성을 보장해야합니다.

- `낙관적 락`(Optimistic Locking)<br>
    충돌 가능성이 낮다는 가정 하에 잠긍르 하지 않으며, 데이터 커밋 시점에 출동을 확인합니다.<br>
    주로 읽기 위주의 환경에서 사용되며, kotlin, spring에서는 `version` 속성 및 `@Version`을 통해 구현합니다.<br>
    ```kotlin
    class Stock(
        @Id
        val stockId: Long,
        val quantity: Int,
        @Version
        val version: Int
    )
    ```
    > 💡 `낙관적 락`의 메커니즘은 주로 데이터의 일관성을 유지하기 위해 업데이트 시점에서 데이터가 변하지 않았음을 검증합니다.<br>
    > 가장 일반적으로 사용하는 방법은 `version` 필드를 활용하는 것이지만, 꼭 `version` 필드를 사용해야만 하는 것은 아닙니다.<br>
    > 예를들어 `timestamp`, `hash`, 등을 이용해 구현이 가능합니다.<br><br>
    > 👉 `timestamp`의 경우 정밀도가 충분히 높지 않는다면 동시에 수행된 여러 트랜잭션을 구분하는 데 여러움이 있을 수 있습니다.<br>
    > 특히 높은 동시성을 요구하는 시스템에서는 이러한 `timestamp` 충돌이 빈번할 수 있습니다.<br>
    > (`timestamp`의 경우 millisecond까지 표기가 가능함으로 nanosecond의 경합이 생길경우 문제가 될 수 있습니다.)<br><br>
    > 👉 `hash`의 경우 해시 함수가 고도로 충돌 저항성을 가져야 하지만, 해시 분석 및 실제 충돌 가능성이 있는 경우, 효율적인 동작에 문제가 발생할 수 있습니다.<br>
    > 특히 동일한 해시값이 서로 다른 데이터 세트를 지닌 경우라면 문제를 초래할 수 있습니다.<br><br>
    > 이러한 문제점들로인해 일반적으로 사용되는 `version`필드를 사용하는 것을 권장됩니다.

- `비관전 락`(Pessimistic Locking)<br>
    데이터 접근 시 항상 잠금을 통해 충동을 원천적으로 방지합니다. `FOR UPDATE`구문을 통해 구현할 수 있습니다.<br>
    > 💡 `비관적 락`은 항상 잠금을 사용함으로, `mvcc`와는 반대의 접근 방식입니다.<br>
    > `mvcc`가 읽기 작업의 효율성을 높인다면, `비관적 락`은 수정이나, 충돌 빈도가 높은 환경에서 일관성을 보장하는 데 사용됩니다.

<br><br>

## e-커머스 서비스 환경에서 발생한 동시성 이슈
동시성 이슈가 발생한 기능은 [`포인트 충전/사용`](#포인트-충전사용), [`선착순 쿠폰 발급`](#선착순-쿠폰-발급), [`재고차감`](#재고차감)이 있었습니다.<br>
발생한 이슈는 어떠한 [`데이터 잠금`](#데이터-잠금)을 활용하여 동시성 이슈를 해결했는지를 설명합니다.<br><br>

### 포인트 충전/사용
해당 기능은 주로 `따닥이슈`, `충전/사용 동시요청`, 등의 이유로 동시성 이슈를 유발했습니다.<br>
`비관적 락`을 활용할 경우 요청이 거절되어 사용자가 다시 진행해야한다는 점에서 사용자 경험에 안좋은 영향이 있을 것으로 예상되어 `낙관적 락`을 활용 동시성 이슈를 해결했습니다.<br><br>

### 선착순 쿠폰 발급
해당 기능은 제한된 수량의 쿠폰을 여러 사용자가 동시에 요청할 경우가 많아. 동시성 이슈를 유발하고, 요청들은 충돌이 많은 것으로 예상됩니다.<br>
따라서 `비관적 락`을 활용 동시성 이슈를 해결했습니다.<br><br>

### 재고차감
해당 기능은 다수의 주문이 동시에 들어옴에 따라 초기 재고 수량이 일관되지 않게 반영될 가능성이 있을 때 발생합니다.<br>
해당 기능은 인기상품이 아닐 경우 많은 충돌이 예상되지는 않으나, 일관성을 보장을 확실히 하기위해 `비관적 락`을 활용 동시성 이슈를 해결했습니다.<br><br>